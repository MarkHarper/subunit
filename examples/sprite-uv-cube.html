<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="../bower_components/threejs/build/three.js"></script>
    <script src="vendor/d3.js"></script>
    <script src="vendor/tween.min.js"></script>
    <script src="vendor/OrbitControls.js"></script>
    <script src="../dist/subunit.js"></script>
  </head>
  <body>
    <script>

      var camera, scene, renderer;
      var mesh;

      d3.json('assets/zombies.json', function init(err, data) {

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        renderer.setClearColor('#EAEAEA');

        d3.select("canvas").style("opacity", 0)
        d3.select("canvas").transition().duration(2000).style("opacity", 1)

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 500;

        scene = new THREE.Scene();

        var light = new THREE.HemisphereLight('#ffffff', '#666666', 1.25)
        scene.add(light);

        var texture = THREE.ImageUtils.loadTexture('assets/carpet.jpg');
        texture.anisotropy = renderer.getMaxAnisotropy();

        var material = new THREE.MeshLambertMaterial({map: texture, side: THREE.DoubleSide});
        var geometry = new THREE.BoxGeometry(300, 450, 10);

        var movie = THREE.ImageUtils.loadTexture('assets/zombies.jpg');
        var matrl = new THREE.MeshLambertMaterial({map: movie, side: THREE.DoubleSide});
        var plane = new THREE.PlaneGeometry(300, 450);

        // function getAttr(items) {

        //   var spriteW = d3.max(items, function (d) {
        //     return d.width + d.positionX;
        //   });

        //   var spriteH = d3.max(items, function (d) {
        //     return d.height + d.positionY;
        //   });

        //   var getImageCoords = function (obj) {
        //     return [
        //       [obj.px1, obj.py1], // TOP LEFT
        //       [obj.px1, obj.py2], // BOT LEFT
        //       [obj.px2, obj.py1], // TOP RIGHT
        //       [obj.px2, obj.py2]  // BOT RIGHT
        //     ];
        //   };

        //   var getUV = function (item) {
        //     var perm = d3.permute;

        //     var coords = getImageCoords({
        //       px1: item.positionX / spriteW,
        //       py1: item.positionY / spriteH,
        //       px2: (item.positionX + item.width) / spriteW,
        //       py2: (item.positionY + item.height) / spriteH
        //     });

        //     item.uv = d3.merge(perm(coords, [0, 1, 3]), perm(coords, [1, 2, 3]));

        //     return item;
        //   };

        //   return items.map(getUV);
        // }

        function getUVs(items) {

          var spriteW = d3.max(items, function (d) {
            return d.width + d.positionX;
          });

          var spriteH = d3.max(items, function (d) {
            return d.height + d.positionY;
          });

          var getImageCoords = function (obj) {
            return [
              new THREE.Vector2(obj.px1, obj.py1),
              new THREE.Vector2(obj.px2, obj.py1),
              new THREE.Vector2(obj.px2, obj.py2),
              new THREE.Vector2(obj.px1, obj.py2)
            ];
          };

          var getUV = function (item, i) {
            var perm = d3.permute;

            var coords = getImageCoords({
              px1: item.positionX / spriteW,
              py1: 1 - ((item.positionY + item.height) / spriteH),
              px2: (item.positionX + item.width) / spriteW,
              py2: 1 - (item.positionY / spriteH)
            });

            if (i === 7) {
              console.log("item", item, coords, spriteW, spriteH);
            }

            item.uv = [perm(coords, [3, 0, 2]), perm(coords, [0, 1, 2])];

            return item;
          };

          return items.map(getUV);
        }

        console.log("uvs", getUVs(data.images))

        plane.faceVertexUvs[0] = getUVs(data.images)[10].uv
        plane.uvsNeedUpdate = true;

        console.log(geometry, plane, data);

        mesh = new THREE.Mesh(plane, matrl);

        scene.add( mesh );

        //

        window.addEventListener( 'resize', onWindowResize, false );
        animate();

      });

      // d3.json('assets/zombies.json', function init(err, data) {

      //   renderer = new THREE.WebGLRenderer();
      //   renderer.setSize( window.innerWidth, window.innerHeight );
      //   document.body.appendChild( renderer.domElement );
      //   renderer.setClearColor('#EAEAEA');

      //   camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
      //   camera.position.z = 5;

      //   scene = new THREE.Scene();

      //   var light = new THREE.HemisphereLight('#ffffff', '#666666', 1.25)
      //   scene.add(light);

      //   var texture = THREE.ImageUtils.loadTexture('assets/zombies.jpg');
      //   texture.anisotropy = renderer.getMaxAnisotropy();

      //   var material = new THREE.MeshLambertMaterial({map: texture});

      //   var geometry = new THREE.BufferGeometry()
      //   geometry.fromGeometry(new THREE.BoxGeometry( 2, 2, 2 ));

      //   var spriteW = d3.max(data.images, function (d) {
      //     return d.width + d.positionX;
      //   });

      //   var spriteH = d3.max(data.images, function (d) {
      //     return d.height + d.positionY;
      //   });

      //   var arr = geometry.getAttribute('uv').array;

      //   for (var i = 0; i < arr.length; i++) {
      //       if ((i + 1) % 2 === 0) {
      //         console.log(i, arr[i - 1], arr[i])
      //       }
      //       // if (arr[i] === 1) {
      //       //   arr[i] = 0.001;
      //       // }
      //   };

      //   console.log("buffer geometry", geometry.getAttribute('uv'), data, spriteW, spriteH);

      //   mesh = new THREE.Mesh(geometry, material);
      //   scene.add( mesh );

      //   //

      //   window.addEventListener( 'resize', onWindowResize, false );
      //   animate();

      // });

    //   function init() {

    //     renderer = new THREE.WebGLRenderer();
    //     renderer.setSize( window.innerWidth, window.innerHeight );
    //     document.body.appendChild( renderer.domElement );

    //     //

    //     camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
    //     camera.position.z = 400;

    //     scene = new THREE.Scene();

    // var ambientLight = new THREE.AmbientLight(0x222222, 10);
    // scene.add(ambientLight);

    // var directionalLight = new THREE.PointLight(0xffffff);
    // directionalLight.position.set(500, 0, 20);
    // scene.add(directionalLight);

    // var directionalLight = new THREE.PointLight(0xffffff);
    // directionalLight.position.set(-500, 0, 20);
    // scene.add(directionalLight);


    //     var geometry = new THREE.BoxGeometry( 200, 200, 200 );

    //     var texture  = THREE.ImageUtils.loadTexture('images/carpet.jpg');
    //     texture.anisotropy = renderer.getMaxAnisotropy();

    //     var material = new THREE.MeshPhongMaterial({ map: texture });

    //     // var n = new THREE.MeshPhongMaterial({
    //     //     map: texture,
    //     //     // specular: '#a9fcff',
    //     //     // color: '#00abb1',
    //     //     // emissive: '#006063',
    //     //     // shininess: 100


    //     // });

    //     // var g = new THREE.BufferGeometry()
    //     // g.fromGeometry(geometry);
    //     // // g.computeFaceNormals();
    //     // g.computeVertexNormals();
    //     // g.normalizeNormals();


    //     mesh = new THREE.Mesh( geometry, material);
    //     scene.add( mesh );

    //     //

    //     window.addEventListener( 'resize', onWindowResize, false );

    //   }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {

        requestAnimationFrame( animate );

        mesh.rotation.x += 0.09;
        mesh.rotation.y += 0.02;

        renderer.render( scene, camera );

      }

    </script>
  </body>
</html>